import numpy as np
import itertools
import meshio
import os
import sys
from contextlib import redirect_stdout

import cedar


class Mesh1D(cedar.base.Mesh):
    """
    One-dimensional structured mesh aligned with the z-axis.

    This mesh represents a line of equally spaced cells extending from
    ``start_z`` to ``end_z`` at a fixed ``(x, y)`` location. Cells are
    defined between consecutive points along the z-direction, with
    faces located at point positions.

    The mesh supports a single region and a single boundary, each
    applied to all cells or faces respectively.

    Parameters
    ----------
    N_cells : int
        Number of cells in the mesh.
    start_z : float
        Starting coordinate of the mesh in the z-direction.
    end_z : float
        Ending coordinate of the mesh in the z-direction.
    region : str
        Name of the region applied to all cells.
    boundary : str
        Name of the boundary applied to all faces.
    x : float, optional
        x-coordinate of the mesh (default is 0).
    y : float, optional
        y-coordinate of the mesh (default is 0).

    Attributes
    ----------
    dz : float
        Uniform cell size in the z-direction.
    points : ndarray
        Point coordinates with shape ``(N_cells + 1, 3)``.
    cell_centers : ndarray
        Cell center coordinates with shape ``(N_cells, 3)``.
    face_centers : ndarray
        Face center coordinates (coincident with points).
    face_is_interior : ndarray
        Boolean array indicating interior faces.
    """

    def __init__(self, N_cells, start_z, end_z, region, boundary, x = 0, y = 0):
        self.start_z = start_z
        self.end_z = end_z
        self.dz = (end_z-start_z)/N_cells
        self.x = x
        self.y = y
        
        self.points = np.array([(x, y, start_z + i*self.dz) for i in range(N_cells+1)])
        
        self.N_cells = np.array(N_cells)
        self.cell_point_ids = np.array([(i, i+1) for i in range(N_cells)])
        self.cell_face_ids = np.copy(self.cell_point_ids)

        self.cell_centers = np.array([0.5*(self.points[i] + self.points[i+1]) for i in range(N_cells)])

        self.N_faces = N_cells + 1
        self.face_point_ids = np.array([[i] for i in range(N_cells+1)])

        self.face_cell_ids = [[0, 0]]
        for i in range(self.N_faces-2):
            self.face_cell_ids.append([i, i+1])
        self.face_cell_ids.append([N_cells - 1, 0])

        self.face_cell_ids = np.array(self.face_cell_ids)

        self.face_is_interior = np.full(self.N_faces, True)
        self.face_is_interior[0] = False
        self.face_is_interior[-1] = False
        
        self.face_centers = np.copy(self.points)
        self.face_n = np.full((self.N_faces, 3), (0, 0, 1))
        self.face_L = np.full(self.N_faces, self.dz)
        self.face_L[0] = self.dz/2
        self.face_L[-1] = self.dz/2
        self.face_w = 0.5*np.ones(self.N_faces)
        
        self.regions = {region: np.full(N_cells, True)}
        self.region_cell_ids = {region: np.arange(N_cells)}
        self.region_N = {region: N_cells}

        self.boundaries = {boundary: np.full(self.N_faces, True)}
        self.boundary_face_ids = {boundary: np.arange(self.N_faces)}
        self.boundary_N = {boundary: self.N_faces}

    def get_i_for_z_pos(self, z: float):
        """
        Return the cell index corresponding to a z-position.

        The index is determined by locating the first interior face
        whose z-coordinate is greater than or equal to the input value.
        Values beyond the mesh extent are clamped to the last cell.

        Parameters
        ----------
        z : float
            Position in the z-direction.

        Returns
        -------
        int
            Cell index containing the specified position.
        """
        if z >= self.end_z - self.dz:
            return self.N_cells-1
        
        interior_face_z = [pos[2] for pos in self.face_centers[self.face_is_interior]]

        for i in range(len(interior_face_z)):
            if z <= interior_face_z[i]:
                return i

class Mesh3D(cedar.base.Mesh):
    """
    Three-dimensional unstructured tetrahedral mesh.

    This class constructs a computational mesh from a tetrahedral mesh
    file (e.g., generated by Gmsh) using ``meshio``. It extracts points,
    cells, faces, regions, and boundaries, and computes all required
    geometric quantities for finite-volume-style discretizations.

    Regions and boundaries are inferred from named cell sets in the
    input mesh file.

    Parameters
    ----------
    filename : str
        Path to the mesh file, relative to the main script directory.

    Attributes
    ----------
    points : ndarray
        Array of mesh point coordinates with shape ``(N_points, 3)``.

    N_cells : int
        Number of tetrahedral cells.

    cell_point_ids : ndarray
        Array of shape ``(N_cells, 4)`` mapping each cell to its point indices.

    cell_face_ids : ndarray
        Array of shape ``(N_cells, 4)`` mapping each cell to its face indices.

    cell_centers : ndarray
        Coordinates of cell centroids.

    cell_vols : ndarray
        Volumes of each cell.

    N_faces : int
        Number of unique triangular faces in the mesh.

    face_point_ids : ndarray
        Array of shape ``(N_faces, 3)`` mapping each face to its point indices.

    face_cell_ids : ndarray
        Array of shape ``(N_faces, 2)`` giving adjacent cell indices.
        The second entry is zero for boundary faces.

    face_is_interior :ndarray
        Boolean array indicating whether each face is interior.

    face_centers : ndarray
        Coordinates of face centroids.

    face_areas : ndarray
        Face areas.

    face_n : ndarray
        Unit normal vectors for each face.

    face_L : .ndarray
        Characteristic face length used in flux calculations.

    face_w : ndarray
        Face weighting factors for interpolation.

    regions : dict
        Mapping of region names to boolean cell masks.

    region_cell_ids : dict
        Mapping of region names to arrays of cell indices.

    region_N : dict
        Mapping of region names to cell counts.

    region_vols : dict
        Mapping of region names to total region volumes.

    boundaries : dict
        Mapping of boundary names to boolean face masks.

    boundary_face_ids : dict
        Mapping of boundary names to arrays of face indices.

    boundary_N : dict
        Mapping of boundary names to face counts.

    boundary_areas : dict
        Mapping of boundary names to total boundary areas.

    vol : float
        Total mesh volume.
    """
        
    def __init__(self, filename: str):
        main_file_path = os.path.abspath(str(sys.modules["__main__"].__file__))
        path = os.path.dirname(main_file_path) + "/" + filename

        with open(os.devnull, 'w') as f:
            with redirect_stdout(f):
                mesh0: meshio.Mesh = meshio.read(path)
        self._remove_gmsh_data(mesh0)

        # Point Information
        self.points = np.copy(mesh0.points)

        # Cell Information
        self.N_cells = len(mesh0.cells_dict["tetra"])
        self.cell_point_ids = np.zeros((self.N_cells, 4), dtype = np.int64)
        self.cell_face_ids = np.zeros((self.N_cells, 4), dtype = np.int64)

        self.cell_centers = np.zeros((self.N_cells, 3))
        self.cell_vols = np.zeros((self.N_cells))

        # Face Information -- We can't initialize yet because we won't know how
        # many faces there are until we build geometry. This is because some
        # faces are shared by 2 cells. These attributes will be initialized in
        self.N_faces: np.ndarray = None
        self.face_point_ids: np.ndarray = None
        self.face_cell_ids: np.ndarray = None
        self.face_is_interior: np.ndarray = None

        self.face_centers: np.ndarray = None
        self.face_areas: np.ndarray = None
        self.face_n: np.ndarray = None
        self.face_L: np.ndarray = None
        self.face_w: np.ndarray = None

        # Region & Boundary Information
        self.regions = {}
        self.region_cell_ids = {}
        self.region_N = {}
        self.region_vols = {}

        self.boundaries = {}
        self.boundary_face_ids = {}
        self.boundary_N = {}
        self.boundary_areas = {}
        
        # Create Geometry
        self._build_geometry(mesh0)

        # Overall Mesh Information
        self.vol = sum(self.region_vols.values())

    def _build_geometry(self, mesh0: meshio.Mesh):
        # Faces are defined by _create_cells because we need to ensure only one
        # face is created if its shared by multiple cells.
        face_dict = self._create_cells(mesh0)
        self._create_faces(face_dict)
        self._define_regions(mesh0)
        self._define_boundaries(mesh0, face_dict)

    def _remove_gmsh_data(self, mesh0: meshio.Mesh):
        initial_keys = list(mesh0.cell_sets.keys())
        for key in initial_keys:
            if key.startswith("gmsh:"):
                del mesh0.cell_sets[key]

    def _create_cells(self, mesh0: meshio.Mesh):
        face_dict = {}
        new_face_id = 0

        ## CELLS
        for cell_id, point_ids in enumerate(mesh0.cells_dict["tetra"]):
            self.cell_point_ids[cell_id] = point_ids

            p1 = self.points[point_ids[0]]
            p2 = self.points[point_ids[1]]
            p3 = self.points[point_ids[2]]
            p4 = self.points[point_ids[3]]

            self.cell_vols[cell_id] = cedar.helper.tetra_vol(p1, p2, p3, p4)
            self.cell_centers[cell_id] = cedar.helper.tetra_center(p1, p2, p3, p4)

            # We will need to create a face for every combination of 3
            # points from the 4 cell points.
            combinations = itertools.combinations(point_ids, 3)

            # Get each face or create it if it doesnt exist.
            for i, face_point_ids in enumerate(combinations):
                # Sort the 3 points in ascending order to create a unique face ID
                sorted_combination = np.sort(face_point_ids)

                # This face key is only temporary to determine unique
                # faces and won't be put in long term storage.
                face_key = str(sorted_combination[0]) + "_" + str(sorted_combination[1]) + "_" + str(sorted_combination[2])

                # If key is not in face_dict, then this is a new face
                if face_key not in face_dict:
                    face_id = new_face_id
                    new_face_id += 1

                    face_dict[face_key] = [face_id, face_point_ids, cell_id, None]

                # If key is in all faces, then its already been created
                else:
                    face_id = face_dict[face_key][0]
                    face_dict[face_key][3] = cell_id

                self.cell_face_ids[cell_id][i] = face_id

        return face_dict

    def _create_faces(self, face_dict: dict):
        # Now we know N_faces, so can initialize the face-related attributes
        # that we didn't earlier in __init__
        self.N_faces = len(face_dict.keys())
        self.face_point_ids = np.zeros((self.N_faces, 3), dtype = np.int64)
        self.face_cell_ids = np.zeros((self.N_faces, 2), dtype = np.int64)
        self.face_is_interior = np.full(self.N_faces, False)

        self.face_centers = np.zeros((self.N_faces, 3))
        self.face_areas = np.zeros(self.N_faces)
        self.face_n = np.zeros((self.N_faces, 3))
        self.face_L = np.zeros(self.N_faces)
        self.face_w = np.zeros(self.N_faces)

        for face_id, face_point_ids, cell_id1, cell_id2 in face_dict.values():
            # Points associated with face
            self.face_point_ids[face_id] = face_point_ids

            # Cells associated with face
            self.face_cell_ids[face_id][0] = cell_id1

            # Check if this is an interior face
            if cell_id2 is not None:
                self.face_cell_ids[face_id][1] = cell_id2
                self.face_is_interior[face_id] = True

            # Face geometry calculations
            p1 = self.points[face_point_ids[0]]
            p2 = self.points[face_point_ids[1]]
            p3 = self.points[face_point_ids[2]]

            self.face_centers[face_id] = cedar.helper.triangle_center(p1, p2, p3)
            self.face_areas[face_id] = cedar.helper.triangle_area(p1, p2, p3)
            self.face_n[face_id] = cedar.helper.triangle_normal(p1, p2, p3)

            # Now, we need characteristic length and weighting factor
            if(self.face_is_interior[face_id]):
                f = self.cell_centers[cell_id2] - self.cell_centers[cell_id1]
                d1 = np.linalg.norm(self.cell_centers[cell_id1] - self.face_centers[face_id])
                d2 = np.linalg.norm(self.cell_centers[cell_id2] - self.face_centers[face_id])
                self.face_w[face_id] = 1/(1+(d1/d2))

            else:
                f = self.cell_centers[cell_id1] - self.face_centers[face_id]
                self.face_w[face_id] = 1

            self.face_L[face_id] = np.linalg.norm(np.dot(f, self.face_n[face_id]))

    def _define_regions(self, mesh0: meshio.Mesh):
        for cell_set_name in mesh0.cell_sets_dict.keys():
            if "tetra" in mesh0.cell_sets_dict[cell_set_name].keys():
                self.regions[cell_set_name] = np.full(self.N_cells, fill_value = False, dtype = bool)

                for cell_id in mesh0.cell_sets_dict[cell_set_name]["tetra"]:
                    self.regions[cell_set_name][cell_id] = True

                self.region_N[cell_set_name] = sum(self.regions[cell_set_name])
                self.region_cell_ids[cell_set_name] = np.array(mesh0.cell_sets_dict[cell_set_name]["tetra"])
                self.region_vols[cell_set_name] = sum(self.cell_vols[self.regions[cell_set_name]])
    
    def _define_boundaries(self, mesh0: meshio.Mesh, face_dict: dict):
        for cell_set_name in mesh0.cell_sets_dict.keys():
            if "triangle" in mesh0.cell_sets_dict[cell_set_name].keys():
                self.boundaries[cell_set_name] = np.full(self.N_faces, fill_value = False, dtype = bool)
                
                face_ids = []
                boundary_area = 0

                for cell_id_2d in mesh0.cell_sets_dict[cell_set_name]["triangle"]:
                    points = mesh0.cells_dict["triangle"][cell_id_2d]
                    sorted_combination = np.sort(points)
                    face_key = str(sorted_combination[0]) + "_" + str(sorted_combination[1]) + "_" + str(sorted_combination[2])
                    face_id = face_dict[face_key][0]

                    self.boundaries[cell_set_name][face_id] = True

                    face_ids.append(face_id)
                    boundary_area += self.face_areas[face_id]

                self.boundary_N[cell_set_name] = sum(self.boundaries[cell_set_name])
                self.boundary_face_ids[cell_set_name] = np.array(face_ids)
                self.boundary_areas[cell_set_name] = np.array(boundary_area)